<!DOCTYPE HTML>
<HTML lang="en-US">
  <HEAD>
    <TITLE>My space invaders</TITLE>
    <LINK rel="icon" href="data:image/x-icon;base64,AAABAAEAJCQQAAEABABYBAAAFgAAACgAAAAkAAAASAAAAAEABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAQAAAAIAAAIAAHkMBAB4DgQAeg4EAHoOBgD//f8A//7/AP///QD///4A/v//AP///wAAAAAAAAAAiIh4dwAAAAB2d3dnAAAAAAAAAAB4iHd2AAAAAHd3h3cAAAAAAAAAd3fd7XWHAAB1h+zOaGcAAAAAAAB1fgAAZWUAAHWHAgB3eAAAAAAAdWeRACANdwAAd+QCRAtVVwAAAAB3dwBAQA13AAB3wCIiAGd3AAAAAHXgAEIB3nd3d3bOAAICCWYAAAAAiOQAAg3uZ3d3d93jIgQJZgAAAAB34gIA6d3Md1ftqr00QAl3AAAAAHXgIA7pnZx3dZ6q3eEACncAAAAAdd4A7e7u3u7p7dnr7kTOiAAAAABV7qvu60DeQQDZAO6e2e6IAAAAAIVm7t2wFEQCQgIESercVlUAAAAAhWadANJEBCQiAQMcEN5mVQAAAAB3u7IiLkAhABAAAOAELJ11AAAAAHe5kCIJwAAAMAIZsEQO3XUAAABniO2QIg2UIAIgAEqhAgveiGYAAHd4rjBCDuAABBAAC6AAAOmIZgAAh+qwAAIO4CQRACEewQQATtxWAACH2uIRMA4hBBACMgKgRDAOnFYAAFW5rQAA4AAgAiIgJC0ABN3dVgAAVbut7avgEgACIAAiDczu7d1VAABV7q3uvqoAngABriLd3Z7p3VYAAFWe3iSuqu4gBAAA3e7dFO7uZwAAdnawRA7u0CACAEBM6aAACYVmAABVVZAAKu6kBAAAEA2+oCIOhmYAAABVkQAO68AENAAEDpnARD6FAAAAAFWQFAvc4ABEBAQu6cAADoYAAAAAZsAEDmXrEyBAALuFoAQKeAAAAAB25AAOZc7QRCAJu2ikAAl3AAAAAGZmAJpnVaoQMO5nV94gh3gAAAAAZ1bu6mdVqe7t7ndnrqpXVgAAAAAAh3WIV3d3zJtmZlZ3VXcAAAAAAABVVYhVd4fc7nZ3VVVVdwAAAAAAAAAAAAAAd4iHZgAAAAAAAAAAAAAAAAAAAABVVVeHAAAAAAAAAAAA/AP8A/AAAAD8A/wD8AAAAPAA8ADwAAAA8ADwAPAAAADAAPAAMAAAAMAA8AAwAAAAwAAAADAAAADAAAAAMAAAAMAAAAAwAAAAwAAAADAAAADAAAAAMAAAAMAAAAAwAAAAwAAAADAAAADAAAAAMAAAAMAAAAAwAAAAwAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAwAAAAwAAAADAAAADAAAAAMAAAAMAAAAAwAAAAwAAAADAAAADAAAAAMAAAAPAAAADwAAAA8AAAAPAAAAD//AP/8AAAAP/8A//wAAAA">
    <STYLE>
      html {
        color: white;
        display: flex;
        flex-direction: column;
        font-family: 'Times New Roman', Times, serif;
        min-height: 100%;
      }
      body {
        background: black;
        display: flex;
        flex: 1;
        flex-direction: column;
        margin: 0;
        padding: 16px;
      }
      noscript {
        background: orange;
        color: black;
        padding: 16px;
      }
      #game-container {
        position: relative;
      }
      #game-field {
        background: darkblue;
        border-radius: 8px;
        filter: blur(4px);
        image-rendering: pixelated;
        max-height: calc(100vh - 34px - 56px - 96px);
        object-fit: contain;
        padding: 4px;
        width: calc(100% - 8px);
      }
      #game-container:focus #game-field {
        filter: none;
      }
      #game-container:fullscreen #game-field {
        border-radius: 0;
        height: calc(100vh - 8px);
        max-height: none;
      }
      :root.ios-fullscreen #game-field {
        border-radius: 0;
        flex: 1;
        max-height: none;
        min-height: 0;
      }
      .game-char {
        color: deeppink;
        font-size: 16px;
        font-weight: bold;
        position: absolute;
      }
      .game-blood {
        pointer-events: none;
        position: absolute;
        z-index: 1;
      }
      .game-blood svg {
        animation: 10s ease-out blood-spill;
        fill: maroon;
        stroke: transparent;
        pointer-events: fill;
      }
      @keyframes blood-spill {
        0% {
          transform: scale(0);
          fill: red;
        }
        20% {
          transform: scale(1);
          fill: crimson;
        }
        100% {
          fill: maroon;
        }
      }
      #hidden-menu {
        align-items: center;
        display: none;
        flex-direction: column;
        left: 50%;
        position: fixed;
        top: 2px;
        transform: translateX(-50%);
        transform-origin: top center;
      }
      #hidden-menu-summoner {
        background-color: black;
        border: 1px solid white;
        border-radius: 4px;
        color: white;
        margin: 0;
        padding: 4px;
        opacity: 0.5;
        transition: opacity 0.3s ease-in;
      }
      #hidden-menu-summoner:active {
        opacity: 1;
      }
      #hidden-menu-summoner svg {
        display: block;
      }
      #hidden-menu-buttons {
        background-color: black;
        border: 1px solid green;
        border-radius: 2px;
        display: none;
        gap: 4px;
        justify-content: center;
        padding: 1px;
      }
      #hidden-menu-buttons button {
        background: transparent;
        border: 1px solid white;
        border-radius: 2px;
        color: white;
        display: block;
        padding: 0;
      }
      #hidden-menu-buttons button:active {
        border-color: lightblue;
        color: lightblue;
      }
      #hidden-menu-buttons svg {
        display: block;
        margin: auto;
        width: 40px;
      }
      #gesture-reference {
        border: 4px solid blue;
        border-radius: 50%;
        display: none;
        height: 64px;
        opacity: 0.5;
        position: fixed;
        transform: translate(-50%, -50%);
        width: 64px;
      }
      #victory-message {
        background-color: #00000080;
        color: green;
        display: none;
        font-size: 2rem;
        font-weight: 600;
        left: 50%;
        max-width: 100%;
        position: absolute;
        text-align: center;
        top: 50%;
        transform: translate(-50%, -50%);
        width: max-content;
      }
      #game-bar {
        border: 1px solid green;
        border-radius: 4px;
        display: flex;
        gap: 4px;
        justify-content: center;
        padding: 4px;
      }
      #game-bar button {
        background: transparent;
        border: 1px solid white;
        border-radius: 4px;
        color: white;
        display: block;
        padding: 2px;
      }
      #game-bar button:active {
        border-color: lightblue;
        color: lightblue;
      }
      #game-bar svg {
        display: block;
        margin: auto;
        width: 40px;
      }
      ul {
        margin: 0;
      }
      #gyro-button {
        appearance: none;
        background: white;
        border: 4px solid darkblue;
        border-radius: 4px;
        color: block;
        font-weight: bold;
        margin: 0;
        outline: none;
        padding: 4px;
      }
      #gyro-button:hover, #gyro-button:focus-visible {
        border-color: green;
      }
      #gyro-button:active {
        border-color: darkseagreen;
      }
      #gyro-error {
        color: red;
        display: none;
      }
      #conditional {
        color: deeppink;
        display: none;
      }
      footer {
        background: darkblue;
        margin: -16px;
        margin-top: auto;
        padding: 16px;
        text-align: center;
      }
      kbd {
        background-color: lightgray;
        border-radius: 4px;
        color: black;
        display: inline-block;
        font-size: 1rem;
        font-weight: bold;
        padding: 2px 4px;
        vertical-align: baseline;
      }
      a {
        color: cornflowerblue;
      }
      a:active {
        color: darkseagreen;
      }
      textarea {
        resize: none;
        width: 100%;
      }
      .revealed-hints {
        color: deeppink;
      }
      .revealed-hints.hidden {
        display: none;
      }
      .hint-answers.hidden {
        display: none;
      }
      .hint-history-question {
        font-style: italic;
      }
      .hint-history-answer {
        font-weight: 500;
      }
      :root.ios-fullscreen body > :not(#game-container) {
        display: none !important;
      }
      :root.ios-fullscreen #game-container {
        display: flex;
        flex: 1;
        flex-direction: column;
        min-height: 0;
      }
      :root.ios-fullscreen body {
        min-height: 0;
        padding: 0;
        touch-action: none;
      }
      :root.ios-fullscreen {
        bottom: 0;
        left: 0;
        min-height: 0;
        position: fixed;
        right: 0;
        top: 0;
      }
      * {
        text-size-adjust: none;
      }
    </STYLE>
  </HEAD>
  <BODY>
    <NOSCRIPT>Enable JavaScript to play this game.</NOSCRIPT>
    <DIV id="game-container" tabindex="0" role="application">
      <CANVAS id="game-field" width="320" height="240" aria-label="The &quot;my space invaders&quot; game canvas.">
        This is where you would play the game, but your browser seems to not be able to render it.
      </CANVAS>
      <DIV id="hidden-menu">
        <BUTTON id="hidden-menu-summoner" type="button">
          <SVG viewBox="0 0 16 4" width="24" height="6" fill="currentColor" stroke="transparent">
            <CIRCLE r="2" cx="2" cy="2"></CIRCLE>
            <CIRCLE r="2" cx="8" cy="2"></CIRCLE>
            <CIRCLE r="2" cx="14" cy="2"></CIRCLE>
          </SVG>
        </BUTTON>
        <DIV id="hidden-menu-buttons">
          <BUTTON id="hidden-fullscreen" type="button" title="Play game in fullscreen.">
            <SVG viewBox="0 0 20 16" stroke="currentColor" stroke-width="1" fill="transparent" aria-label="Fullscreen icon">
              <PATH d="M1 7V5A4 4 0 0 1 5 1H9"></PATH>
              <PATH d="M11 1H15A4 4 0 0 1 19 5V7"></PATH>
              <PATH d="M19 9V11A4 4 0 0 1 15 15H11"></PATH>
              <PATH d="M9 15H5A4 4 0 0 1 1 11V9"></PATH>
              <PATH d="M3 6V3H6M3 3L6 6"></PATH>
              <PATH d="M17 6V3H14M17 3L14 6"></PATH>
              <PATH d="M17 10V13H14M17 13L14 10"></PATH>
              <PATH d="M3 10V13H6M3 13L6 10"></PATH>
              <PATH d="M9 6H11A2 2 0 0 1 11 10H9A2 2 0 0 1 9 6"></PATH>
            </SVG>
          </BUTTON>
          <BUTTON id="hidden-window-mode" type="button" title="Exit fullscreen.">
            <SVG viewBox="0 0 20 16" stroke="currentColor" stroke-width="1" fill="transparent" aria-label="Fullscreen icon">
              <PATH d="M3 1L17 15"></PATH>
              <PATH d="M17 1L3 15"></PATH>
            </SVG>
          </BUTTON>
          <BUTTON id="hidden-restart" type="button" title="Restart the game.">
            <SVG viewBox="0 0 20 16" aria-label="Restart icon">
              <G stroke="currentColor" stroke-width="1" fill="transparent">
                <PATH d="M4 7A6 6 0 0 1 16 7"></PATH>
                <PATH d="M16 9A6 6 0 0 1 4 9"></PATH>
              </G>
              <G stroke="transparent" fill="currentColor">
                <PATH d="M16 7L13 4H19"></PATH>
                <PATH d="M4 9L1 12H7"></PATH>
              </G>
            </SVG>
          </BUTTON>
        </DIV>
      </DIV>
      <DIV id="victory-message">Alien attack subverted! Good job.</DIV>
      <DIV id="gesture-reference"></DIV>
    </DIV>
    <DIV id="game-bar">
      <BUTTON id="game-button-fullscreen" type="button" title="Play game in fullscreen.">
        Fullscreen
        <SVG viewBox="0 0 20 16" stroke="currentColor" stroke-width="1" fill="transparent" aria-label="Fullscreen icon">
          <PATH d="M1 7V5A4 4 0 0 1 5 1H9"></PATH>
          <PATH d="M11 1H15A4 4 0 0 1 19 5V7"></PATH>
          <PATH d="M19 9V11A4 4 0 0 1 15 15H11"></PATH>
          <PATH d="M9 15H5A4 4 0 0 1 1 11V9"></PATH>
          <PATH d="M3 6V3H6M3 3L6 6"></PATH>
          <PATH d="M17 6V3H14M17 3L14 6"></PATH>
          <PATH d="M17 10V13H14M17 13L14 10"></PATH>
          <PATH d="M3 10V13H6M3 13L6 10"></PATH>
          <PATH d="M9 6H11A2 2 0 0 1 11 10H9A2 2 0 0 1 9 6"></PATH>
        </SVG>
      </BUTTON>
      <BUTTON id="game-button-restart" type="button" title="Restart the game.">
        Restart
        <SVG viewBox="0 0 20 16" aria-label="Restart icon">
          <G stroke="currentColor" stroke-width="1" fill="transparent">
            <PATH d="M4 7A6 6 0 0 1 16 7"></PATH>
            <PATH d="M16 9A6 6 0 0 1 4 9"></PATH>
          </G>
          <G stroke="transparent" fill="currentColor">
            <PATH d="M16 7L13 4H19"></PATH>
            <PATH d="M4 9L1 12H7"></PATH>
          </G>
        </SVG>
      </BUTTON>
    </DIV>
    <H2>Controls</H2>
    <P>You can play using a keyboard or using a touch screen or using a gyroscope.</P>
    <P>
      Keyboard:
    </P>
    <UL>
      <LI>Left arrow key <KBD>&larr;</KBD>: Move to the left.</LI>
      <LI>Right arrow key <KBD>&rarr;</KBD>: Move to the right.</LI>
      <LI>Control key <KBD>Ctrl ^</KBD> or the S letter key <KBD>S</KBD>: Shoot a rocket.</LI>
      <LI><KBD>F</KBD>: Toggle fullscreen.</LI>
      <LI><KBD>R</KBD>: Restart the game.</LI>
      <LI>Click on stains to clean them up.</LI>
    </UL>
    <P>
      Touch screen:
    </P>
    <UL>
      <LI>Touch and hold the game field (anywhere) to summon the touch reference (blue circle).</LI>
      <LI>Using a screen in landscape orientation in fullscreen is recommended to maximise the space where you can touch the screen.</LI>
      <LI>Swipe (and <B>hold</B>) to the left of the touch reference: Move to the left.</LI>
      <LI>Swipe (and <B>hold</B>) to the right of the touch reference: Move to the right.</LI>
      <LI>Swipe (and hold) upwards above the touch reference: Shoot a rocket.</LI>
      <LI>Note that the edges of the screen remain reserved for pan and zoom gestures, so the touch reference doesn't activate there. This provides an escape hatch when zoomed in too much on the game.</LI>
      <LI>Also note that when the game is blurred, pan and zoom gestures are also enabled and when the game is active, a kebab menu button appears at the top of the screen. Opening this menu will blur the game.</LI>
    </UL>
    <P>
      Gyroscope (tilting a mobile device):
    </P>
    <UL>
      <LI>Tap this button to enable gyroscope controls (or disable them afterwards). This will disable touch screen controls. <BUTTON id="gyro-button" type="button">Enable gyroscope controls</BUTTON><DIV id="gyro-error"></DIV></DIV></LI>
      <LI>Hold the device in front of you. Landscape orientation in fullscreen is recommended, but profile orientation and windowed mode are also supported. The device may stand upwards or may lay down with the screen facing upwards.</LI>
      <LI>Move the ship to the left by tilting the device leftwards (moving the left side of the device closer towards the ground than the right side).</LI>
      <LI>Move the ship to the right by tilting the device rightwards (moving the right side of the device closer towards the ground than the left side).</LI>
      <LI>Tap the game field to shoot a rocket.</LI>
      <LI>Note that the edges of the screen remain reserved for pan and zoom gestures, so the touch reference doesn't activate there. This provides an escape hatch when zoomed in too much on the game.</LI>
      <LI>Also note that when the game is blurred, pan and zoom gestures are also enabled and when the game is active, a kebab menu button appears at the top of the screen. Opening this menu will blur the game.</LI>
    </UL>
    <H2>Game description &amp; goal</H2>
    <P>
      A game based on the famous arcade game "<A href="https://en.wikipedia.org/wiki/Space_Invaders">Space invaders</A>".
      Defend earth from an alien assault.
      Shoot rockets from within your spaceship to eliminate the aliens before they reach earth or kill you.
    </P>
    <P id="conditional">
      It looks like the aliens are holding secret intel.
      Try to figure out what they're hiding!
    </P>
    <H2>Hints</H2>
    <P class="revealed-hints hidden">Revealed hints:</P>
    <UL class="revealed-hints hidden"></UL>
    <P id="hint-explanation">
      If you're having difficulty figuring out what to do, you can get a hint by answering the following question:
    </P>
    <P id="hint-question">Loading question...</P>
    <FORM id="hint-form">
      <TEXTAREA name="Answer" required minlength="10" placeholder="Your answer." rows="4"></TEXTAREA>
      <INPUT type="submit" value="Confirm answer">
      <INPUT id="reset-hint-question" type="button" value="Different question please">
    </FORM>
    <P>
      Consider sending your response to the author of this game &#128521.
    </P>
    <P class="hint-answers hidden">
      Your earlier answers:
    </P>
    <UL class="hint-answers hidden"></UL>
    <P></P>
    <FOOTER>
      &copy; 2023 Jo-Thijs Daelman (<a href="mailto:jo_thijs@msn.com">jo_thijs@msn.com</a>)
    </FOOTER>
    <!-- UTILS -->
    <SCRIPT type="text/javascript">
      function assert(check) {
        const [value, valid] = check();
        if (!valid) {
          console.error(`Assertion failed on:`, value);
          throw new Error("Assertion failed.");
        }
      }
      function* upTo(nonInclusiveLimit) {
        assert(() => [nonInclusiveLimit, typeof nonInclusiveLimit === 'number']);
        for (let i = 0; i < nonInclusiveLimit; i++) {
          yield i;
        }
      }
      function clamp(x, min, max) {
        assert(() => [x, typeof x === "number"]);
        assert(() => [min, typeof min === "number"]);
        assert(() => [max, typeof max === "number"]);
        return Math.max(Math.min(x, max), min);
      }
      function isPoint(value) {
        return typeof value === "object"
          && value !== null
          && typeof value.x === "number"
          && typeof value.y === "number";
      }
      function isRect(value) {
        return typeof value === "object"
          && value !== null
          && typeof value.minX === "number"
          && typeof value.minY === "number"
          && typeof value.maxX === "number"
          && typeof value.maxY === "number";
      }
      function isPointInRect(point, rect) {
        assert(() => [point, isPoint(point)]);
        assert(() => [rect, isRect(rect)]);
        return point.x <= rect.maxX
          && point.x >= rect.minX
          && point.y <= rect.maxY
          && point.y >= rect.minY;
      }
      function rectsIntersection(...rects) {
        assert(() => [rects, Array.isArray(rects)]);
        assert(() => [rects, rects.every((rect) => isRect(rect))]);
        const candidate = {
          minX: Math.max(...rects.map((rect) => rect.minX)),
          minY: Math.max(...rects.map((rect) => rect.minY)),
          maxX: Math.min(...rects.map((rect) => rect.maxX)),
          maxY: Math.min(...rects.map((rect) => rect.maxY)),
        };
        return candidate.minX <= candidate.maxX && candidate.minY <= candidate.maxY ? candidate : null;
      }
      function isPointToRender(value) {
        return typeof value === "object"
          && value !== null
          && "x" in value
          && "y" in value
          && "primary" in value
          && typeof value.x === "number"
          && typeof value.y === "number"
          && typeof value.primary === "boolean";
      }
      function isSprite(value) {
        return Array.isArray(value) && value.every(isPointToRender);
      }
      function extendSpriteWithRightMirror(sprite) {
        assert(() => [sprite, isSprite(sprite)]);
        const rightX = Math.max(...sprite.map(({ x }) => x));
        return [...sprite, ...sprite.map(({ x, y, primary }) => ({ x: rightX * 2 + 1 - x, y, primary }))];
      }
      function decodeSprite(offset, encoding) {
        assert(() => [offset, typeof offset === "object" && offset !== null]);
        assert(() => [offset.x, "x" in offset && typeof offset.x === "number"]);
        assert(() => [offset.y, "y" in offset && typeof offset.y === "number"]);
        assert(() => [encoding, typeof encoding === "string" && /^[#\/ \r\n]*$/.test(encoding)]);
        const sprite = [];
        let x = offset.x;
        let y = offset.y;
        for (const char of encoding) {
          switch (char) {
          case "\n": x = offset.x; y++; continue;
          case "#": sprite.push({ x, y, primary: true }); break;
          case "/": sprite.push({ x, y, primary: false }); break;
          }
          x++;
        }
        return sprite;
      }
      function renderPoints(ctx, points, targetX, targetY, options) {
        assert(() => [ctx, ctx instanceof CanvasRenderingContext2D]);
        assert(() => [points, isSprite(points)]);
        assert(() => [targetX, typeof targetX === "number"]);
        assert(() => [targetY, typeof targetY === "number"]);
        assert(() => [options, ["undefined", "object"].includes(typeof options) && options !== null]);
        assert(() => [options?.primaryColor, ["undefined", "string"].includes(typeof options?.primaryColor)]);
        function strokeSameColoredPoints(primaryFilter) {
          ctx.beginPath();
          for (const { x, y, primary } of points) {
            if (primary === primaryFilter) {
              ctx.moveTo(targetX + x, targetY + y);
              ctx.lineTo(targetX + x + 1, targetY + y + 1);
            }
          }
          ctx.moveTo(0, 0);
          ctx.closePath();
          ctx.stroke();
        }
        ctx.strokeStyle = options?.primaryColor ?? "white";
        strokeSameColoredPoints(true);
        ctx.strokeStyle = "black";
        strokeSameColoredPoints(false);
      }
      async function memEfficientAnimationFrameLoop(iteration) {
        let terminate = false;
        while (!terminate) {
          await new Promise((resolve, reject) => {
            requestAnimationFrame((...args) => {
              try {
                terminate = iteration(...args);
                resolve();
              } catch (error) {
                reject(error);
              }
            });
          });
        }
      }
      function isIosSafari() {
        // Stolen from https://stackoverflow.com/a/29696509
        const ua = window.navigator.userAgent;
        const iOS = !!ua.match(/iPad/i) || !!ua.match(/iPhone/i);
        const webkit = !!ua.match(/WebKit/i);
        const iOSSafari = iOS && webkit && !ua.match(/CriOS/i);
        return iOSSafari;
      }
      function delayOnIosSafari(callback) {
        assert(() => [callback, typeof callback === "function"]);
        if (isIosSafari()) {
          setTimeout(callback, 0);
        } else {
          callback();
        }
      }
    </SCRIPT>
    <!-- HINT QUESTIONS -->
    <SCRIPT type="text/javascript">
      const hintQuestions = {
        energy: "What is your source of energy or motivation?",
        learn: "Given enough resources, what would you like to learn or experience first?",
        proud: "What are your proudest achievements?",
        description: "How would friends or family describe you?",
        communities: "What communities or social groups most represent you or do you most enjoy interacting with?",
        art: "What elements would an artwork about you (in an artform of your choice) need to include or focus on?",
        laugh: "What are some specific examples that made you laugh recently?",
      };
      const hintSecret = [
        new Int8Array([
          84, 104, 101, 32, 103, 111,
          97, 108, 32, 111, 102, 32,
          116, 104, 101, 32, 103, 97,
          109, 101, 32, 105, 115, 32,
          110, 111, 116, 32, 116, 111,
          32, 107, 105, 108, 108, 32,
          97, 108, 108, 32, 97, 108,
          105, 101, 110, 115, 44, 32,
          98, 117, 116, 32, 116, 111,
          32, 117, 110, 99, 111, 118,
          101, 114, 32, 116, 104, 101,
          32, 109, 101, 115, 115, 97,
          103, 101, 32, 116, 104, 101,
          121, 32, 103, 114, 97, 100,
          117, 97, 108, 108, 121, 32,
          114, 101, 118, 101, 97, 108,
          32, 119, 104, 101, 110, 32,
          107, 105, 108, 108, 101, 100,
          46,
        ]),
        new Uint8Array([
          84, 104, 105, 115, 32, 109,
          101, 115, 115, 97, 103, 101,
          32, 105, 115, 32, 97, 110,
          32, 69, 110, 103, 108, 105,
          115, 104, 32, 115, 101, 110,
          116, 101, 110, 99, 101, 46,
        ]),
        new Uint8Array([
          65, 110, 32, 97, 108, 105,
          101, 110, 32, 105, 115, 32,
          105, 100, 101, 110, 116, 105,
          102, 105, 101, 100, 32, 98,
          121, 32, 116, 104, 101, 105,
          114, 32, 115, 116, 97, 114,
          116, 105, 110, 103, 32, 112,
          111, 115, 105, 116, 105, 111,
          110, 46, 32, 75, 105, 108,
          108, 105, 110, 103, 32, 116,
          104, 101, 32, 115, 97, 109,
          101, 32, 97, 108, 105, 101,
          110, 32, 111, 118, 101, 114,
          32, 50, 32, 103, 97, 109,
          101, 115, 44, 32, 109, 97,
          107, 101, 115, 32, 116, 104,
          101, 109, 32, 100, 114, 111,
          112, 32, 116, 104, 101, 32,
          115, 97, 109, 101, 32, 99,
          104, 97, 114, 97, 99, 116,
          101, 114, 32, 97, 103, 97,
          105, 110, 46,
        ]),
        new Uint8Array([
          84, 104, 101, 32, 97, 108,
          105, 101, 110, 115, 32, 99,
          97, 114, 114, 121, 32, 99,
          104, 97, 114, 97, 99, 116,
          101, 114, 115, 32, 111, 102,
          32, 116, 104, 101, 32, 115,
          101, 110, 116, 101, 110, 99,
          101, 32, 105, 110, 32, 116,
          104, 101, 32, 111, 114, 100,
          101, 114, 32, 116, 104, 101,
          121, 32, 111, 99, 99, 117,
          114, 32, 105, 110, 32, 116,
          104, 101, 32, 115, 101, 110,
          116, 101, 110, 99, 101, 46,
          32, 83, 111, 32, 116, 104,
          101, 32, 102, 105, 114, 115,
          116, 32, 97, 108, 105, 101,
          110, 32, 105, 110, 32, 116,
          104, 101, 32, 116, 111, 112,
          32, 114, 111, 119, 44, 32,
          99, 97, 114, 114, 105, 101,
          115, 32, 116, 104, 101, 32,
          102, 105, 114, 115, 116, 32,
          99, 104, 97, 114, 97, 99,
          116, 101, 114, 32, 111, 102,
          32, 116, 104, 101, 32, 115,
          101, 110, 116, 101, 110, 99,
          101, 46, 32, 84, 104, 101,
          32, 102, 105, 110, 97, 108,
          32, 97, 108, 105, 101, 110,
          32, 111, 110, 32, 116, 104,
          101, 32, 98, 111, 116, 116,
          111, 109, 32, 114, 111, 119,
          32, 99, 97, 114, 114, 105,
          101, 115, 32, 116, 104, 101,
          32, 108, 97, 115, 116, 32,
          99, 104, 97, 114, 97, 99,
          116, 101, 114, 32, 111, 102,
          32, 116, 104, 101, 32, 115,
          101, 110, 116, 101, 110, 99,
          101, 46, 32, 83, 112, 97,
          99, 101, 115, 32, 105, 110,
          32, 116, 104, 101, 32, 115,
          101, 110, 116, 101, 110, 99,
          101, 32, 97, 114, 101, 32,
          97, 108, 115, 111, 32, 99,
          97, 114, 114, 105, 101, 100,
          32, 98, 121, 32, 97, 108,
          105, 101, 110, 115, 44, 32,
          115, 111, 32, 105, 116, 32,
          119, 105, 108, 108, 32, 108,
          111, 111, 107, 32, 108, 105,
          107, 101, 32, 116, 104, 101,
          121, 32, 100, 114, 111, 112,
          32, 110, 111, 116, 104, 105,
          110, 103, 46,
        ]),
        new Uint8Array([
          65, 108, 105, 101, 110, 115,
          32, 115, 104, 111, 111, 116,
          32, 108, 101, 115, 115, 32,
          102, 114, 101, 113, 117, 101,
          110, 116, 108, 121, 32, 97,
          115, 32, 116, 104, 101, 121,
          32, 110, 101, 97, 114, 32,
          101, 97, 114, 116, 104, 46,
          32, 84, 104, 105, 115, 32,
          109, 97, 107, 101, 115, 32,
          105, 116, 32, 115, 97, 102,
          101, 114, 32, 116, 111, 32,
          117, 110, 108, 111, 97, 100,
          32, 114, 111, 99, 107, 101,
          116, 115, 32, 97, 116, 32,
          116, 104, 101, 32, 102, 105,
          110, 97, 108, 32, 102, 101,
          119, 32, 97, 108, 105, 101,
          110, 115, 32, 105, 110, 32,
          116, 104, 101, 32, 102, 105,
          110, 97, 108, 32, 115, 116,
          114, 101, 116, 99, 104, 101,
          115, 46, 32, 70, 117, 114,
          116, 104, 101, 114, 109, 111,
          114, 101, 44, 32, 121, 111,
          117, 114, 32, 115, 112, 97,
          99, 101, 115, 104, 105, 112,
          32, 115, 104, 111, 111, 116,
          115, 32, 114, 111, 99, 107,
          101, 116, 115, 32, 102, 114,
          111, 109, 32, 105, 116, 115,
          32, 115, 105, 100, 101, 115,
          44, 32, 98, 117, 116, 32,
          97, 108, 105, 101, 110, 115,
          32, 100, 111, 32, 115, 104,
          111, 111, 116, 32, 112, 114,
          111, 106, 101, 99, 116, 105,
          108, 101, 115, 32, 102, 114,
          111, 109, 32, 116, 104, 101,
          32, 99, 101, 110, 116, 101,
          114, 32, 111, 102, 32, 116,
          104, 101, 105, 114, 32, 98,
          111, 100, 105, 101, 115, 46,
          32, 84, 104, 105, 115, 32,
          109, 97, 107, 101, 115, 32,
          105, 116, 32, 115, 111, 32,
          121, 111, 117, 32, 99, 97,
          110, 32, 107, 101, 101, 112,
          32, 97, 108, 105, 101, 110,
          115, 32, 105, 110, 32, 115,
          104, 111, 111, 116, 105, 110,
          103, 32, 114, 97, 110, 103,
          101, 32, 119, 105, 116, 104,
          111, 117, 116, 32, 102, 97,
          108, 108, 105, 110, 103, 32,
          105, 110, 116, 111, 32, 116,
          104, 101, 32, 97, 108, 105,
          101, 110, 115, 39, 115, 32,
          115, 104, 111, 111, 116, 105,
          110, 103, 32, 114, 97, 110,
          103, 101, 46, 32, 84, 104,
          105, 115, 32, 109, 105, 103,
          104, 116, 32, 109, 97, 107,
          101, 32, 121, 111, 117, 32,
          109, 105, 115, 115, 32, 109,
          111, 114, 101, 32, 98, 117,
          108, 108, 101, 116, 115, 32,
          97, 110, 100, 32, 114, 105,
          115, 107, 32, 108, 111, 115,
          105, 110, 103, 32, 116, 105,
          109, 101, 32, 104, 111, 119,
          101, 118, 101, 114, 46,
        ]),
        new Uint8Array([
          87, 104, 101, 110, 32, 102,
          105, 114, 105, 110, 103, 32,
          97, 32, 114, 111, 99, 107,
          101, 116, 44, 32, 121, 111,
          117, 114, 32, 115, 104, 105,
          112, 32, 110, 101, 101, 100,
          115, 32, 116, 111, 32, 114,
          101, 99, 111, 118, 101, 114,
          32, 102, 111, 114, 32, 97,
          32, 109, 111, 109, 101, 110,
          116, 32, 98, 101, 102, 111,
          114, 101, 32, 105, 116, 32,
          99, 97, 110, 32, 115, 104,
          111, 111, 116, 32, 97, 32,
          110, 101, 119, 32, 114, 111,
          99, 107, 101, 116, 46, 32,
          73, 116, 39, 115, 32, 109,
          111, 114, 101, 32, 101, 102,
          102, 105, 99, 105, 101, 110,
          116, 32, 116, 111, 32, 102,
          105, 114, 101, 32, 97, 116,
          32, 116, 104, 105, 115, 32,
          114, 121, 116, 104, 109, 32,
          116, 104, 97, 110, 32, 116,
          111, 32, 115, 112, 97, 109,
          32, 102, 105, 114, 105, 110,
          103, 32, 114, 111, 99, 107,
          101, 116, 115, 46,
        ]),
        new Uint8Array([
          84, 104, 97, 116, 39, 115,
          32, 97, 108, 108, 32, 111,
          102, 32, 116, 104, 101, 32,
          116, 105, 112, 115, 46, 32,
          84, 104, 97, 110, 107, 115,
          32, 102, 111, 114, 32, 97,
          110, 115, 119, 101, 114, 105,
          110, 103, 32, 97, 108, 108,
          32, 116, 104, 101, 32, 113,
          117, 101, 115, 116, 105, 111,
          110, 115, 33,
        ]),
      ];
      const getHintAnswers = () => {
        try {
          const parsed = JSON.parse(localStorage.getItem("hint-answers") ?? "");
          if (typeof parsed !== "object") {
            return {};
          }
          return parsed;
        } catch {
          return {};
        }
      };
      let hintKey = undefined;
      const pickNewHintKey = () => {
        const hintAnswers = getHintAnswers();
        const remainingKeys = Object.keys(hintQuestions).filter((key) => !(key in hintAnswers));
        const index = Math.floor(Math.random() * remainingKeys.length);
        hintKey = remainingKeys[index];
      };
      pickNewHintKey();
      const hintQuestionElement = document.getElementById("hint-question");
      const hintFormElement = document.getElementById("hint-form");
      const hintAnswerElements = document.getElementsByClassName("hint-answers");
      const hintAnswerParagraph = hintAnswerElements.item(0);
      const hintAnswerList = hintAnswerElements.item(1);
      const revealedHintsElements = document.getElementsByClassName("revealed-hints");
      const revealedHintsParagraph = revealedHintsElements.item(0);
      const revealedHintsList = revealedHintsElements.item(1);
      const updateHintUi = () => {
        if (hintQuestionElement) {
          if (hintKey) {
            hintQuestionElement.innerText = hintQuestions[hintKey];
          } else {
            hintQuestionElement.style.display = "none";
            const formElement = document.getElementsByTagName("form").item(0);
            if (formElement) {
              formElement.style.display = "none";
            }
            const hintExplanationElement = document.getElementById("hint-explanation");
            if (hintExplanationElement) {
              hintExplanationElement.style.display = "none";
            }
          }
        }
        if (hintAnswerParagraph && hintAnswerList && revealedHintsParagraph && revealedHintsParagraph) {
          const hintAnswers = getHintAnswers();
          const entries = Object.entries(hintAnswers);
          if (entries.length > 0) {
            hintAnswerParagraph.classList.remove("hidden");
            hintAnswerList.classList.remove("hidden");
            revealedHintsParagraph.classList.remove("hidden");
            revealedHintsList.classList.remove("hidden");
          }
          [...hintAnswerList.childNodes].forEach((child) => {
            hintAnswerList.removeChild(child);
          });
          [...revealedHintsList.childNodes].forEach((child) => {
            revealedHintsList.removeChild(child);
          });
          entries.forEach(([key, value], index) => {
            const newHistoryItem = document.createElement("li");
            const header = document.createElement("P");
            const body = document.createElement("P");
            header.innerText = hintQuestions[key];
            body.innerText = value;
            header.classList.add("hint-history-question");
            body.classList.add("hint-history-answer");
            newHistoryItem.appendChild(header);
            newHistoryItem.appendChild(body);
            hintAnswerList.appendChild(newHistoryItem);
            const newRevealedItem = document.createElement("li");
            newRevealedItem.innerText = new TextDecoder().decode(hintSecret[index]);
            revealedHintsList.appendChild(newRevealedItem);
          });
        }
      };
      updateHintUi();
      if (hintFormElement instanceof HTMLFormElement) {
        hintFormElement.addEventListener("submit", (event) => {
          event.preventDefault();
          const answer = new FormData(hintFormElement).get("Answer") ?? "";
          localStorage.setItem("hint-answers", JSON.stringify({ ...getHintAnswers(), [hintKey]: answer }));
          hintFormElement.reset();
          pickNewHintKey();
          updateHintUi();
          if (revealedHintsParagraph) {
            revealedHintsParagraph.scrollIntoView({ behavior: "smooth", block: "nearest" })
          }
        });
      }
      document.getElementById("reset-hint-question").addEventListener("click", () => {
        hintFormElement?.reset();
        pickNewHintKey();
        updateHintUi();
      });
    </SCRIPT>
    <!-- GAME BAR BUTTONS -->
    <SCRIPT type="text/javascript">
      const gameFocusElement = document.getElementById("game-container");
      // FULLSCREEN BUTTON
      const fullscreenButton = document.getElementById("game-button-fullscreen");
      const toggleFullscreen = () => {
        if (isIosSafari()) {
          const classes = document.documentElement.classList;
          if (classes.contains("ios-fullscreen")) {
            classes.remove("ios-fullscreen");
            const metaElement = document.querySelector("head > meta[name=\"viewport\"]");
            if (metaElement) {
              document.head.removeChild(metaElement);
            }
          } else {
            classes.add("ios-fullscreen");
            const metaElement = document.createElement("meta");
            metaElement.name = "viewport";
            metaElement.content = "minimum-scale=1.0, maximum-scale=1.0, initial-scale=1.0";
            document.head.appendChild(metaElement);
          }
        } else {
          if (document.fullscreen) {
            document.exitFullscreen();
          } else {
            gameFocusElement.requestFullscreen({ navigationUI: "hide" });
          }
          gameFocusElement.focus();
        }
      };
      fullscreenButton.addEventListener("click", toggleFullscreen);
      gameFocusElement.addEventListener("keypress", (event) => {
        if (event.key.toLowerCase() === 'f') {
          toggleFullscreen();
        }
      });
      // RESTART BUTTON
      const restartButton = document.getElementById("game-button-restart");
      const restartGame = () => {
        runningGame.terminate()
        runningGame = startGame();
        gameFocusElement.focus();
      };
      restartButton.addEventListener("click", restartGame);
      gameFocusElement.addEventListener("keypress", (event) => {
        if (event.key.toLowerCase() === 'r') {
          restartGame();
        }
      });
    </SCRIPT>
    <!-- HIDDEN MENU -->
    <SCRIPT type="text/javascript">
      const hiddenMenuContainerElement = document.getElementById("hidden-menu");
      const summonerElement = document.getElementById("hidden-menu-summoner");
      const hiddenMenuButtonsContainerElement = document.getElementById("hidden-menu-buttons");
      const hiddenFullscreenButton = document.getElementById("hidden-fullscreen");
      const hiddenWindowModeButton = document.getElementById("hidden-window-mode");
      const hiddenRestartButton = document.getElementById("hidden-restart");
      const hiddenMenuButtons = [hiddenFullscreenButton, hiddenWindowModeButton, hiddenRestartButton];
      const hiddenMenuTargetElements = [
        document.getElementById("game-container"),
        summonerElement,
      ];
      for (const targetElement of hiddenMenuTargetElements) {
        targetElement.addEventListener("focus", () => {
          hiddenMenuContainerElement.style.display = "flex";
          if (targetElement === summonerElement) {
            summonerElement.style.opacity = 1;
          }
          if (targetElement.id === "game-container") {
            delayOnIosSafari(() => {
              summonerElement.style.opacity = null;
              hiddenMenuButtonsContainerElement.style.display = null;
            });
          }
        });
        targetElement.addEventListener("blur", (event) => {
          if (
            !hiddenMenuTargetElements.includes(event.relatedTarget)
            && !hiddenMenuButtons.includes(event.relatedTarget)
          ) {
            delayOnIosSafari(() => {
              hiddenMenuContainerElement.style.display = null;
            });
          }
          if (
            summonerElement !== event.relatedTarget
            && !hiddenMenuButtons.includes(event.relatedTarget)
          ) {
            delayOnIosSafari(() => {
              summonerElement.style.opacity = null;
              hiddenMenuButtonsContainerElement.style.display = null;
            });
          }
        });
      }
      const updateHiddenMenuTransform = () => {
        const dx = clamp(visualViewport.offsetLeft, 0, document.documentElement.clientWidth - visualViewport.width) + visualViewport.width / 2 - document.documentElement.clientWidth / 2;
        const dy = clamp(visualViewport.offsetTop, 0, document.documentElement.clientHeight - visualViewport.height);
        hiddenMenuContainerElement.style.transform = `translateX(-50%) translate(${dx}px, ${dy}px) scale(${1 / visualViewport.scale})`;
      }
      visualViewport.addEventListener("resize", updateHiddenMenuTransform);
      visualViewport.addEventListener("scroll", updateHiddenMenuTransform);
      summonerElement.addEventListener("click", () => {
        hiddenMenuButtonsContainerElement.style.display = "flex";
      });
      hiddenFullscreenButton.addEventListener("click", toggleFullscreen);
      hiddenWindowModeButton.addEventListener("click", toggleFullscreen);
      hiddenRestartButton.addEventListener("click", restartGame);
      hiddenWindowModeButton.style.display = "none";
      document.addEventListener("fullscreenchange", () => {
        if (document.fullscreenElement === null) {
          hiddenFullscreenButton.style.display = null;
          hiddenWindowModeButton.style.display = "none";
        } else {
          hiddenFullscreenButton.style.display = "none";
          hiddenWindowModeButton.style.display = null;
        }
      });
      if (isIosSafari()) {
        summonerElement.addEventListener("click", () => {
          summonerElement.focus();
        });
      }
    </SCRIPT>
    <!-- SPRITES -->
    <SCRIPT type="text/javascript">
      gameSprites = {};
      gameSprites.spaceshipIdle = extendSpriteWithRightMirror(decodeSprite({ x: -8, y: -8 }, [
        "       #",
        "  ##  ##",
        " #/# ##/",
        " #/###//",
        " #/###//",
        "########",
        "#####/#/",
        "##//##/#",
        " ##/##//",
        " ##/##/#",
        "  ###/#/",
        " #######",
        " #/####",
        " #//##",
        "  #//#",
        "   ##",
      ].join("\n")));
      gameSprites.playerBullet = decodeSprite({ x: -1, y: 0 }, [
        " #",
        "#/#",
        " #",
        "# #",
      ].join("\n"));
      gameSprites.explosion = extendSpriteWithRightMirror(decodeSprite({ x: -5, y: -5 }, [
        "    #",
        "  /#/",
        " /#/#",
        " #/#/",
        "#/#/#",
        "/#/#/",
        " /#/#",
        " #/#/",
        "  #/#",
        "    /",
      ].join("\n")));
      gameSprites.fatAlienImg1 = extendSpriteWithRightMirror(decodeSprite({ x: -8, y: -8 }, [
        "   #### ",
        "  ##//##",
        " #######",
        " ##//##/",
        "########",
        "#####//#",
        "#//#//##",
        "########",
        "######/#",
        " #//#///",
        " ######/",
        "  ##//##",
        "   #####",
        "  #   ##",
        " #   #  ",
        " #  #   ",
        "    #   ",
      ].join("\n")));
      gameSprites.fatAlienImg2 = extendSpriteWithRightMirror(decodeSprite({ x: -8, y: -8 }, [
        "   #### ",
        "  ##//##",
        " #######",
        " ##//##/",
        "########",
        "####///#",
        "#//##/##",
        "########",
        "######/#",
        " #//#///",
        " #####//",
        "  ##//#/",
        "   #####",
        " ##   ##",
        "#   ##  ",
        "   #    ",
        "        ",
      ].join("\n")));
      gameSprites.inkAlienImg1 = extendSpriteWithRightMirror(decodeSprite({ x: -8, y: -8 }, [
        "       #",
        "      ##",
        "     ###",
        "     ##/",
        "    ####",
        "    ##/#",
        "   ##/##",
        "  #/##/#",
        " ##/#//#",
        " #/#####",
        "  #/###/",
        "   ### #",
        " ## #  #",
        "#  #  # ",
        "#  #  # ",
        "   #  # ",
        "      # ",
      ].join("\n")));
      gameSprites.inkAlienImg2 = extendSpriteWithRightMirror(decodeSprite({ x: -8, y: -8 }, [
        "       #",
        "      ##",
        "     ###",
        "     ##/",
        "    ####",
        "    ##/#",
        "   #####",
        "  #/#//#",
        " ##/##/#",
        " #/#####",
        "  #/###/",
        " ####  #",
        "#  #  # ",
        "# #  #  ",
        "  #  #  ",
        "   # #  ",
        "        ",
      ].join("\n")));
      gameSprites.alienBullet = decodeSprite({ x: -1, y: 0 }, [
        " #",
        "#",
        "#",
        " #",
        " #",
        "# ",
      ].join("\n"));
    </SCRIPT>
    <!-- CONTROLS -->
    <SCRIPT type="text/javascript">
      const currentKeyConfig = {
        left: false,
        right: false,
        action: false,
      };
      const previousKeyConfig = { ...currentKeyConfig };
      const convertKey = (key) => {
        switch (key) {
        case "ArrowLeft": return "left";
        case "ArrowRight": return "right";
        case "Control": return "action";
        case "S": case "s": return "action";
        default: return null;
        }
      };
      document.getElementById("game-container").addEventListener("keydown", (event) => {
        const key = convertKey(event.key);
        if (key) {
          currentKeyConfig[key] = true;
        }
        event.preventDefault();
      });
      addEventListener("keyup", (event) => {
        const key = convertKey(event.key);
        if (key) {
          currentKeyConfig[key] = false;
        }
      });
      let gyroEnabled = false;
      let touchingId = null;
      let originPoint = { x: 0, y: 0 };
      let currentPoint = { x: 0, y: 0 };
      const gestureThreshold = 32;
      const gestureReferenceElement = document.getElementById("gesture-reference");
      const isTouchAtEdge = (touch) => {
        if (isIosSafari()) {
          // Apple doesn't seem to have understood what screen coordinates are for touch objects, so we need a special approach.
          return (
            touch === null
            || touch.screenX < visualViewport.offsetLeft + 32
            || touch.screenY < visualViewport.offsetTop + 32
            || touch.screenX >= visualViewport.offsetLeft + visualViewport.width - 32
            || touch.screenY >= visualViewport.offsetTop + visualViewport.height - 32
          );
        } else {
          return (
            touch === null
            || touch.screenX < 16
            || touch.screenY < 16
            || touch.screenX >= screen.width - 16
            || touch.screenY >= screen.height - 16
          );
        }
      };
      document.getElementById("game-field").addEventListener("touchstart", (event) => {
        if (gyroEnabled) {
          return;
        }
        if (gamePaused) {
          return;
        }
        if (touchingId !== null) {
          return;
        }
        const relevantTouch = event.changedTouches.item(0);

        if (isTouchAtEdge(relevantTouch)) {
          return;
        }
        touchingId = relevantTouch.identifier;
        originPoint = isIosSafari() ? {
            x: relevantTouch.screenX,
            y: relevantTouch.screenY,
          } : {
            x: relevantTouch.clientX,
            y: relevantTouch.clientY,
          };
        currentPoint = originPoint;
        gestureReferenceElement.style.display = "block";
        gestureReferenceElement.style.left = `${originPoint.x}px`;
        gestureReferenceElement.style.top = `${originPoint.y}px`;
        event.preventDefault();
      });
      addEventListener("touchend", (event) => {
        if (touchingId === null) {
          return;
        }
        for (let i = 0; i < event.changedTouches.length; i++) {
          if (event.changedTouches.item(i).identifier !== touchingId) {
            continue;
          }
          touchingId = null;
          currentKeyConfig.left = false;
          currentKeyConfig.right = false;
          currentKeyConfig.action = false;
          gestureReferenceElement.style.display = "none";
        }
      });
      addEventListener("touchmove", (event) => {
        if (touchingId === null) {
          return;
        }
        for (let i = 0; i < event.changedTouches.length; i++) {
          const relevantTouch = event.changedTouches.item(i);
          if (relevantTouch.identifier !== touchingId) {
            continue;
          }
          const scale = 1 / visualViewport.scale;
          currentPoint = isIosSafari() ? {
            x: relevantTouch.screenX,
            y: relevantTouch.screenY,
          } : {
            x: relevantTouch.clientX,
            y: relevantTouch.clientY,
          };
          originPoint = {
            x: clamp(originPoint.x, currentPoint.x - gestureThreshold * 2 * scale, currentPoint.x + gestureThreshold * 2 * scale),
            y: clamp(originPoint.y, currentPoint.y - gestureThreshold * 2 * scale, currentPoint.y + gestureThreshold * 2 * scale),
          };
          currentKeyConfig.right = currentPoint.x - originPoint.x >= gestureThreshold * scale;
          currentKeyConfig.left = currentPoint.x - originPoint.x <= -gestureThreshold * scale;
          currentKeyConfig.action = currentPoint.y - originPoint.y <= -gestureThreshold * scale;
          gestureReferenceElement.style.left = `${originPoint.x}px`;
          gestureReferenceElement.style.top = `${originPoint.y}px`;
          event.preventDefault();
        }
      });
      addEventListener("deviceorientation", (event) => {
        if (!gyroEnabled) {
          return;
        }
        const moveTilt = (() => {
          switch (screen.orientation.type) {
            case "landscape-primary": return event.beta * 2;
            case "landscape-secondary": return -event.beta * 2;
            case "portrait-primary": return event.gamma;
            case "portrait-secondary": return -event.gamma;
            default: return 0;
          }
        })();
        currentKeyConfig.right = moveTilt > 30;
        currentKeyConfig.left = moveTilt < -30;
      });
      document.getElementById("game-field").addEventListener("touchstart", (event) => {
        if (!gyroEnabled) {
          return;
        }
        if (gamePaused) {
          return;
        }
        const relevantTouch = event.changedTouches.item(0);
        if (isTouchAtEdge(relevantTouch)) {
          return;
        }
        currentKeyConfig.action = true;
        event.preventDefault();
      });
      addEventListener("touchend", (event) => {
        if (!gyroEnabled) {
          return;
        }
        if (currentKeyConfig.action) {
          currentKeyConfig.action = false;
        }
      });
      const gyroButton = document.getElementById("gyro-button");
      const gyroError = document.getElementById("gyro-error");
      if (gyroButton) {
        gyroButton.addEventListener("click", async () => {
          if (gyroError) {
            gyroError.style.display = null;
          }
          if (!gyroEnabled) {
            if (typeof DeviceOrientationEvent.requestPermission === "function" || true) {
              try {
                await DeviceOrientationEvent.requestPermission();
              } catch (error) {
                console.error('Could not activate gyroscope controls.', error);
                if (gyroError) {
                  gyroError.innerText = `${error}`;
                  gyroError.style.display = "block";
                }
                return;
              }
            }
            gyroEnabled = true;
            gyroButton.innerText = "Disable gyroscope controls";
          } else {
            gyroEnabled = false;
            gyroButton.innerText = "Enable gyroscope controls";
          }
        });
      }
      function getFrameKeyConfig() {
        const result = Object.fromEntries(
          Object.keys(currentKeyConfig).map((key) => [key, {
            pressed: currentKeyConfig[key] && !previousKeyConfig[key],
            released: !currentKeyConfig[key] && previousKeyConfig[key],
            down: currentKeyConfig[key],
          }]),
        );
        Object.assign(previousKeyConfig, currentKeyConfig);
        return result;
      }
      const updateGestureReferenceSize = () => {
        document.getElementById("gesture-reference").style.transform = `translate(-50%, -50%) scale(${1 / visualViewport.scale})`;
      }
      visualViewport.addEventListener("resize", updateGestureReferenceSize);
      updateGestureReferenceSize();
    </SCRIPT>
    <!-- GAMEPLAY -->
    <SCRIPT type="text/javascript">
      // CONFIG
      const gameContainerElement = document.getElementById("game-container");
      const gameFieldElement = document.getElementById("game-field");
      const gameWidth = Number(gameFieldElement.width);
      const gameHeight = Number(gameFieldElement.height);
      const ctx = gameFieldElement.getContext("2d", {
        alpha: false,
      });
      const targetFps = 20;
      const playerSpeed = 2;
      const playerBulletMaxCoolDown = 9;
      const playerBulletSpeed = 7;
      const maxAlienCoolDown = 6;
      const alienSpace = 24;
      const alienColCount = 12;
      const alienSpeed = 2;
      const alienDescentAmount = 12;
      const alienProgressCycle = Math.floor((gameWidth - (alienSpace * (alienColCount - 1) + 16)) / alienSpeed);
      const alienBulletSpeed = 7;
      const expectedAlienBulletsPerSecondOnTop = 2;
      const expectedAlienBulletsPerSecondOnBottom = 0;
      const messageEncoding = new Uint8Array([
        32, 76, 101, 116, 39, 115, 32, 104,
        97, 118, 101, 32, 102, 117, 110, 32,
        116, 111, 103, 101, 116, 104, 101, 114,
      ]);

      // GAME FIELD ANCHORS
      function anchorGameFieldElement(element, position, resizeCallback) {
        assert(() => [element, element instanceof HTMLElement]);
        assert(() => [position, isPoint(position)]);
        assert(() => [resizeCallback, typeof resizeCallback === "function"]);
        const resize = () => {
          const width = gameFieldElement.offsetWidth - 8;
          const height = gameFieldElement.offsetHeight - 8;
          const scale = Math.min(width / gameWidth, height / gameHeight);
          const centerOffset = {
            x: (position.x - gameWidth / 2) * scale,
            y: (position.y - gameHeight / 2) * scale,
          };
          resizeCallback({ scale, centerOffset });
        }
        const resizeObserver = new ResizeObserver(resize);
        resize();
        resizeObserver.observe(gameFieldElement);
        gameContainerElement.appendChild(element);
        const mutationObserver = new MutationObserver(() => {
          if (!gameContainerElement.contains(element)) {
            resizeObserver.disconnect();
            mutationObserver.disconnect();
          }
        });
        mutationObserver.observe(gameContainerElement, {
          childList: true,
        });
      }

      // PAUSE MECHANICS
      let gamePaused = document.activeElement !== gameContainerElement;
      gameContainerElement.addEventListener("focus", () => {
        gamePaused = false;
      });
      gameContainerElement.addEventListener("blur", () => {
        gamePaused = true;
      });

      // RUN GAME
      function startGame() {
        // CLEAN UP CHAR ANCHORS
        document.querySelectorAll(".game-char").forEach((charElement) => {
          charElement.parentElement.removeChild(charElement);
        });

        // CLEAN UP VICTORY MESSAGE
        const victoryMessage = document.getElementById("victory-message");
        if (victoryMessage) {
          victoryMessage.style.display = null;
        }

        // STATE INITIALIZATION
        let gameStarted = false;
        let gameEnded = false;
        let playerDied = false;
        const explosionStates = [];
        const playerBulletStates = [];
        const alienBulletStates = [];
        const alienStates = [...(function* () {
          const message = new TextDecoder().decode(messageEncoding);
          for (const col of upTo(alienColCount)) {
            yield {
              x: 8 + col * alienSpace + alienSpeed,
              y: 12,
              hp: 4,
              type: "fat",
              char: message[col],
              get collisionRect() {
                return {
                  minX: this.x - 8,
                  maxX: this.x + 8,
                  minY: this.y - 8,
                  maxY: this.y + 4,
                };
              },
            };
          }
          for (const col of upTo(alienColCount)) {
            yield {
              x: 8 + col * alienSpace + alienSpeed,
              y: 36,
              hp: 4,
              type: "ink",
              char: message[col + alienColCount],
              get collisionRect() {
                return {
                  minX: this.x - 7,
                  maxX: this.x + 7,
                  minY: this.y - 8,
                  maxY: this.y + 2,
                };
              },
            };
          }
        })()];
        let playerX = Math.floor(gameWidth / 2);
        const playerY = gameHeight - 12;
        let playerBulletCoolDown = 0;
        let playerBulletDirection = 1;
        let alienProgress = 0;
        let alienCoolDown = maxAlienCoolDown;
        let lowestAlienY = 0;

        // BLOOD METHODS
        const createBloodSpat = (position, baseDiameter) => {
          assert(() => [position, isPoint(position)]);
          assert(() => [baseDiameter, typeof baseDiameter === "number"]);
          const containerElement = document.createElement("div");
          containerElement.classList.add("game-blood");
          const svgNs = "http://www.w3.org/2000/svg";
          const svgElement = document.createElementNS(svgNs, "svg");
          svgElement.setAttribute("viewBox", `0 0 ${baseDiameter} ${baseDiameter}`);
          svgElement.setAttribute("width", baseDiameter);
          svgElement.setAttribute("height", baseDiameter);
          containerElement.appendChild(svgElement);
          const circleElement = document.createElementNS(svgNs, "circle");
          circleElement.setAttribute("cx", baseDiameter / 2);
          circleElement.setAttribute("cy", baseDiameter / 2);
          circleElement.setAttribute("r", baseDiameter / 2);
          svgElement.appendChild(circleElement);
          anchorGameFieldElement(containerElement, position, ({ scale, centerOffset }) => {
            containerElement.style.transformOrigin = "center center";
            containerElement.style.transform = `translate(-50%,-50%) scale(${scale})`;
            containerElement.style.left = `calc(50% + (${centerOffset.x}px))`;
            containerElement.style.top = `calc(50% + (${centerOffset.y}px))`;
          });
          let clicked = false;
          circleElement.addEventListener("click", () => {
            if (!clicked) {
              clicked = true;
              containerElement.animate([{ opacity: 1 }, { opacity: 0 }], {
                duration: 500,
                easing: "ease-out",
              }).addEventListener("finish", () => {
                gameContainerElement.removeChild(containerElement);
              });
            }
          });
        };

        const createBloodSplatters = (origin, spatVector) => {
          assert(() => [origin, isPoint(origin)]);
          assert(() => [spatVector, isPoint(spatVector)]);
          let diameter = 16;
          let distance = Math.sqrt(spatVector.x * spatVector.x + spatVector.y * spatVector.y);
          for (let i = 0; i < 6; i++) {
            diameter *= Math.random() * 0.125 + 0.75;
            distance *= Math.random() * 0.125 + 1.125;
            const direction = Math.atan2(spatVector.y, spatVector.x) + (Math.random() - 0.5) * Math.PI * 0.125;
            const position = {
              x: origin.x + Math.cos(direction) * distance,
              y: origin.y + Math.sin(direction) * distance,
            };
            createBloodSpat(position, diameter);
          }
        }

        // PLAYER METHODS
        const getPlayerCollisionRect = () => ({
          minX: playerX - 8,
          maxX: playerX + 8,
          minY: playerY - 8,
          maxY: playerY + 8,
        });
        const updatePlayer = (gameInput) => {
          playerX = clamp(playerX + (gameInput.right.down - gameInput.left.down) * playerSpeed, 8, gameWidth - 8);
          if (playerBulletCoolDown) {
            playerBulletCoolDown--;
          }
          if (gameInput.action.pressed && playerBulletCoolDown === 0) {
            playerBulletCoolDown = playerBulletMaxCoolDown;
            playerBulletStates.push({
              x: playerX + playerBulletDirection * 6,
              y: playerY - 8,
            });
            playerBulletDirection = -playerBulletDirection;
          }
        };
        const renderPlayer = () => {
          renderPoints(ctx, gameSprites.spaceshipIdle, playerX, playerY, { primaryColor: playerDied ? "red" : undefined });
        };

        // EXPLOSION METHODS
        const isExplosionState = (value) => {
          return typeof value === "object"
            && value !== null
            && typeof value.x === "number"
            && typeof value.y === "number"
            && typeof value.lifetime === "number";
        }
        const deleteExplosion = (explosionState) => {
          assert(() => [explosionState, isExplosionState(explosionState)]);
          const index = explosionStates.indexOf(explosionState);
          if (index >= 0) {
            explosionStates.splice(index, 1);
          }
        };
        const updateExplosion = (explosionState) => {
          assert(() => [explosionState, isExplosionState(explosionState)]);
          explosionState.lifetime--;
          if (explosionState.lifetime === 0) {
            deleteExplosion(explosionState);
          }
        };
        const renderExplosion = (explosionState) => {
          assert(() => [explosionState, isExplosionState(explosionState)]);
          renderPoints(ctx, gameSprites.explosion, explosionState.x, explosionState.y);
        };

        // PLAYER BULLET METHODS
        const isPlayerBulletState = (value) => {
          return typeof value === "object"
            && value !== null
            && typeof value.x === "number"
            && typeof value.y === "number";
        }
        const deletePlayerBullet = (bulletState) => {
          assert(() => [bulletState, isPlayerBulletState(bulletState)]);
          const index = playerBulletStates.indexOf(bulletState);
          if (index >= 0) {
            playerBulletStates.splice(index, 1);
          }
        };
        const updatePlayerBullet = (bulletState) => {
          assert(() => [bulletState, isPlayerBulletState(bulletState)]);
          bulletState.y -= playerBulletSpeed;
          if (bulletState.y < -8) {
            deletePlayerBullet(bulletState);
          }
        };
        const renderPlayerBullet = (bulletState) => {
          assert(() => [bulletState, isPlayerBulletState(bulletState)]);
          renderPoints(ctx, gameSprites.playerBullet, bulletState.x, bulletState.y);
        };

        // ALIEN METHODS
        const isAlienState = (value) => {
          return typeof value === "object"
            && value !== null
            && typeof value.x === "number"
            && typeof value.y === "number"
            && typeof value.hp === "number"
            && ["fat", "ink"].includes(value.type)
            && typeof value.char === "string"
            && isRect(value.collisionRect);
        }
        const deleteAlien = (alienState) => {
          assert(() => [alienState, isAlienState(alienState)]);
          const index = alienStates.indexOf(alienState);
          if (index >= 0) {
            alienStates.splice(index, 1);
            const charElement = document.createElement("div");
            charElement.classList.add("game-char");
            charElement.innerText = alienState.char;
            anchorGameFieldElement(charElement, {
              x: alienState.x,
              y: alienState.y,
            }, ({ scale, centerOffset }) => {
              charElement.style.transformOrigin = "center center";
              charElement.style.transform = `translate(-50%,-50%) scale(${scale})`;
              charElement.style.left = `calc(50% + (${centerOffset.x}px))`;
              charElement.style.top = `calc(50% + (${centerOffset.y}px))`;
            });
            const conditionalElement = document.getElementById("conditional");
            if (conditionalElement) {
              conditionalElement.style.display = "block";
            }
            if (alienStates.length === 0) {
              const victoryMessage = document.getElementById("victory-message");
              if (victoryMessage) {
                victoryMessage.style.display = "block";
              }
            }
          }
        };
        const updateAlienForProgress = (alienState) => {
          assert(() => [alienState, isAlienState(alienState)]);
          const direction = Math.floor(alienProgress / alienProgressCycle) & 1 ? -1 : 1;
          alienState.x += alienSpeed * direction;
          if (alienProgress % alienProgressCycle === 0) {
            alienState.y += alienDescentAmount;
            if (alienState.y + 8 >= gameHeight) {
              setTimeout(() => {
                createBloodSplatters({
                  x: alienState.x + (Math.random() - 0.5) * 6,
                  y: gameHeight + 24,
                }, {
                  x: (Math.random() - 0.5) * 6,
                  y: -24,
                })
              }, Math.random() * 500);
              gameEnded = true;
            }
          }
          if (alienState.y > lowestAlienY) {
            lowestAlienY = alienState.y;
          }
          const lowestAlienPercentage = lowestAlienY / gameHeight;
          const expectedAlienBulletsPerSecond = lowestAlienPercentage * (expectedAlienBulletsPerSecondOnBottom - expectedAlienBulletsPerSecondOnTop) + expectedAlienBulletsPerSecondOnTop;
          const alienShootChance = expectedAlienBulletsPerSecond * maxAlienCoolDown / (targetFps * alienColCount * 2);
          if (Math.random() < alienShootChance) {
            alienBulletStates.push({
              x: alienState.x,
              y: alienState.y + 8,
            });
          }
        };
        const handleAlienPlayerBulletCollisions = (alienState) => {
          assert(() => [alienState, isAlienState(alienState)]);
          for (bulletState of playerBulletStates) {
            if (isPointInRect(
              { x: bulletState.x, y: bulletState.y },
              alienState.collisionRect,
            )) {
              deletePlayerBullet(bulletState);
              explosionStates.push({
                x: bulletState.x,
                y: bulletState.y,
                lifetime: 4,
              });
              alienState.hp--;
              if (alienState.hp === 0) {
                deleteAlien(alienState);
              }
            }
          }
        };
        const handleAlienPlayerCollisions = (alienState) => {
          assert(() => [alienState, isAlienState(alienState)]);
            if (rectsIntersection(alienState.collisionRect, getPlayerCollisionRect()) !== null) {
              gameEnded = true;
              playerDied = true;
              const direction = Math.atan2(playerY - alienState.y, playerX - alienState.x);
              createBloodSplatters({
                x: playerX,
                y: playerY,
              }, {
                x: Math.cos(direction) * 8,
                y: Math.sin(direction) * 8,
              });
            }
        };
        const updateAliens = () => {
          alienCoolDown--;
          if (alienCoolDown === 0) {
            alienProgress++;
            alienCoolDown = maxAlienCoolDown;
            for (const alienState of alienStates) {
              updateAlienForProgress(alienState);
            }
          }
          for (const alienState of alienStates) {
            handleAlienPlayerBulletCollisions(alienState);
          }
          for (const alienState of alienStates) {
            handleAlienPlayerCollisions(alienState);
          }
        };
        const renderAlien = (alienState) => {
          assert(() => [alienState, isAlienState(alienState)]);
          const animation = {
            fat: [gameSprites.fatAlienImg1, gameSprites.fatAlienImg2],
            ink: [gameSprites.inkAlienImg1, gameSprites.inkAlienImg2],
          }[alienState.type];
          renderPoints(ctx, animation[alienProgress & 1], alienState.x, alienState.y);
        };

        // ALIEN BULLET METHODS
        const isAlienBulletState = (value) => {
          return typeof value === "object"
            && value !== null
            && typeof value.x === "number"
            && typeof value.y === "number";
        }
        const deleteAlienBullet = (bulletState) => {
          assert(() => [bulletState, isAlienBulletState(bulletState)]);
          const index = playerBulletStates.indexOf(bulletState);
          if (index >= 0) {
            playerBulletStates.splice(index, 1);
          }
        };
        const updateAlienBullet = (bulletState) => {
          assert(() => [bulletState, isAlienBulletState(bulletState)]);
          bulletState.y += alienBulletSpeed;
          if (bulletState.y >= gameHeight + 8) {
            deleteAlienBullet(bulletState);
          }
          if (isPointInRect({
            x: bulletState.x,
            y: bulletState.y,
          }, getPlayerCollisionRect())) {
            gameEnded = true;
            playerDied = true;
            createBloodSplatters({ x: bulletState.x, y: bulletState.y }, { x: 0, y: 12 });
          }
        };
        const renderAlienBullet = (bulletState) => {
          assert(() => [bulletState, isAlienBulletState(bulletState)]);
          renderPoints(ctx, gameSprites.alienBullet, bulletState.x, bulletState.y);
        };

        // GAME LOOP
        let previousFrameTimestamp = Date.now();
        const gameIteration = () => {
          const newFrameTimestamp = Date.now();
          const frameLapseMs = newFrameTimestamp - previousFrameTimestamp;
          if (frameLapseMs >= 1000 / targetFps) {
            previousFrameTimestamp = newFrameTimestamp;
            if (!gamePaused) {
              const gameInput = getFrameKeyConfig();
              if (gameInput.action.pressed || gameInput.left.pressed || gameInput.right.pressed) {
                gameStarted = true;
              }
              if (gameStarted) {
                updatePlayer(gameInput);
                updateAliens();
                for (const bulletState of playerBulletStates) {
                  updatePlayerBullet(bulletState);
                }
                for (const bulletState of alienBulletStates) {
                  updateAlienBullet(bulletState);
                }
                for (const explosionState of explosionStates) {
                  updateExplosion(explosionState);
                }
              }
            }
            ctx.fillStyle = "black";
            ctx.fillRect(0, 0, gameWidth, gameHeight);
            renderPlayer();
            for (const alienState of alienStates) {
              renderAlien(alienState);
            }
            for (const bulletState of playerBulletStates) {
              renderPlayerBullet(bulletState);
            }
            for (const bulletState of alienBulletStates) {
              renderAlienBullet(bulletState);
            }
            for (const explosionState of explosionStates) {
              renderExplosion(explosionState);
            }
          }
          return gameEnded;
        };
        const gameLoop = memEfficientAnimationFrameLoop(gameIteration);
        return {
          async terminate() {
            gameEnded = true;
            return gameLoop;
          }
        };
      };
      runningGame = startGame();
    </SCRIPT>
    <!-- $2a$12$Qok7rtDMAz/N2YW4n1M8HOR1g2mwiD1iqELhrbN170f5RUKnZJOZu -->
  </BODY>
</HTML>
